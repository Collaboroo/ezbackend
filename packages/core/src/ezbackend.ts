import path from "path";
import fs from "fs";
import avvio from "avvio";

//TODO: Make it not unknown
export type IEzbPlugin = avvio.Plugin<unknown, EzBackend>;

export interface IEzbConfig {
  plugins: Array<string>;
  server?: unknown;
  orm?: unknown;
  port?: number;
  connectionURI?: string;
}

export type IEzbPlugins = {
  preInit: Array<IEzbPlugin>;
  init: IEzbPlugin | null;
  postInit: Array<IEzbPlugin>;
  preHandler: Array<IEzbPlugin>;
  handler: IEzbPlugin | null;
  postHandler: Array<IEzbPlugin>;
  preRun: Array<IEzbPlugin>;
  run: IEzbPlugin | null;
  postRun: Array<IEzbPlugin>;
};

export type IEzPlugin<O> = (ezp: EzPlugin<O>, opts: O) => Promise<void>

export type IEzPlugins<O> = {
  preInit: Array<IEzPlugin<O>>;
  init: IEzPlugin<O> | null;
  postInit: Array<IEzPlugin<O>>;
  preHandler: Array<IEzPlugin<O>>;
  handler: IEzPlugin<O> | null;
  postHandler: Array<IEzPlugin<O>>;
  preRun: Array<IEzPlugin<O>>;
  run: IEzPlugin<O> | null;
  postRun: Array<IEzPlugin<O>>;
};

//TODO: Make the stages generated by code
export class EzPlugin<O> {
  manager: avvio.Avvio<EzPlugin<O>>
  plugins: IEzPlugins<O>

  //TODO: Think of why its not throuwing error when the type passed is not exactly an ezbplugin
  constructor() {
    this.plugins = {
      preInit: [],
      init: async (ezp, opts) => {
      },
      postInit: [],
      preHandler: [],
      handler: async (ezp, opts) => {
      },
      postHandler: [],
      preRun: [],
      run: async (ezp, opts) => {
      },
      postRun: [],
    };
    this.manager = avvio(this)
  }

  public async start(opts?: O) {

    const plugins = this.plugins;

    plugins.preInit.forEach(async (plugin) => {
      await plugin(this, opts)
    });

    await plugins.init(this, opts)

    plugins.postInit.forEach(async (plugin) => {
      await plugin(this, opts)
    });

    plugins.preHandler.forEach(async (plugin) => {
      await plugin(this, opts)
    });

    await plugins.handler(this, opts)

    plugins.postHandler.forEach(async (plugin) => {
      await plugin(this, opts)
    });

    plugins.preRun.forEach(async (plugin) => {
      await plugin(this, opts)
    });

    await plugins.run(this, opts)

    plugins.postRun.forEach(async (plugin) => {
      await plugin(this, opts)

    })

    return;

  }
}

export class EzBackend {
  plugins: IEzbPlugins;
  config: IEzbConfig;

  private static instance: EzBackend;
  private static manager: avvio.Avvio<EzBackend>;

  //TODO: Think of why its not throuwing error when the type passed is not exactly an ezbplugin
  constructor() {
    this.plugins = {
      preInit: [],
      init: (ezb, opts, cb) => {
        cb();
      },
      postInit: [],
      preHandler: [],
      handler: (ezb, opts, cb) => {
        cb();
      },
      postHandler: [],
      preRun: [],
      run: (ezb, opts, cb) => {
        cb();
      },
      postRun: [],
    };
  }

  public static initializeApp() {
    if (!EzBackend.instance) {
      EzBackend.instance = new EzBackend();
      EzBackend.manager = avvio(EzBackend.app());
    }
  }

  public static app(): EzBackend {
    EzBackend.initializeApp();
    return EzBackend.instance;
  }

  public static async start(configPath?: string) {

    const customConfigPath =
      configPath ?? path.resolve(process.cwd(), ".ezb/config.ts");

    if (fs.existsSync(customConfigPath)) {
      const ezb = EzBackend.app()
      //URGENT TODO: Consider consequences of putting config in singleton. Perhaps make it readonly?
      ezb.config = require(customConfigPath).default;
      ezb.config.plugins.forEach((pluginName) => {
        //URGENT TODO: Load plugins by running load function, instead of polluting environment with every import
        //URGENT TODO: Make sure that for a new user, the plugins required are resolved from his directory, not the ezbackend directory
        const loadedPlugin = require(pluginName);
      });
    }



    //LOAD PLUGINS FROM CONFIG
    //TODO: Allow changing of config path, or default config if none

    //TODO: Error handling for wrong format of config.ts

    //TODO: Figure out how to pass in options at top level
    EzBackend.manager.use((ezb, opts, cb) => {
      //URGENT TODO: Error handling when plugin doesnt work
      const plugins = ezb.plugins;

      plugins.preInit.forEach((plugin) => {
        ezb.use(plugin, ezb.config);

      });

      ezb.use(plugins.init, ezb.config);


      plugins.postInit.forEach((plugin) => {
        ezb.use(plugin, ezb.config);
      });

      plugins.preHandler.forEach((plugin) => {
        ezb.use(plugin, ezb.config);
      });

      ezb.use(plugins.handler, ezb.config);

      plugins.postHandler.forEach((plugin) => {
        ezb.use(plugin, ezb.config);
      });

      plugins.preRun.forEach((plugin) => {
        ezb.use(plugin, ezb.config);
      });

      ezb.use(plugins.run, ezb.config);

      plugins.postRun.forEach((plugin) => {
        ezb.use(plugin, ezb.config);
      });
      cb();
    });
    EzBackend.manager.start();
    await new Promise<void>(resolve => {
      EzBackend.manager.ready((err) => {
        if (err) {
          throw err;
        }
        resolve()
      });
    })

    return;

  }
}
